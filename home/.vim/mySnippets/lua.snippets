priority 0

###########################
# Custom snippets for lua #
###########################

snippet @module "Module definition" b
------------
-- ${1:module_name}
-- ${2:description}
-- module:  $1
-- author:  `!v get(g:, 'lua_author', $USER)`
-- license: `!v get(g:, 'lua_license', 'MIT')`
endsnippet

global !p
import re
def split_args_types(args):
    """Splits a list of arguments in name and type"""
    def trim_types(arg):
        return arg.replace(' ','')
    # This pattern will fail in the last element if it contains a type
    # with ',' like: 'arg5: {A=string, B=int}' so we add a fake argument
    # to the input that we remove later.
    r = re.compile(r',(?![^,}:]+},)')
    args += ", fake_arg"
    args_xs = re.split(r, args)
    args_xs.pop()

    return [list(map(lambda x: trim_types(x), x)) for x in [a.split(':') for a in args_xs]]

def var_deps(args):
    result = ""
    args_xs = split_args_types(args)

    for arg in args_xs:
        list(arg)
        if len(arg) >= 2:
            dep = "-- {}: {}\n".format(arg[1], arg[0])
        else:
            dep = "-- {}\n".format(arg[0])

        result = result + dep

    return result.rstrip()

def remove_types(fun_name, fun_args, buffer):
    args = split_args_types(fun_args)
    n = len(args) + 1
    arg_names = ", ".join([a[0] for a in args])
    buffer[n] = 'function {}({})'.format(fun_name.current_text, arg_names)
endglobal

post_jump "if snip.tabstop == 3: remove_types(snip.tabstops[1], snip.tabstops[2], snip.buffer)"
snippet !fun(ction)?! "New function" br
--- ${3:description}
`!p snip.rv = var_deps(t[2])`
function ${1:new_function}(${2})
  $0
end
endsnippet
